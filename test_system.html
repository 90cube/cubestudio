<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CUBE Studio ControlNet System Test</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: #1a1a1a;
            color: #e8eaed;
        }
        
        .test-container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .test-section {
            background: #2a2a2a;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid #444;
        }
        
        .test-header {
            color: #3498db;
            margin-bottom: 15px;
        }
        
        .test-result {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-family: monospace;
        }
        
        .test-pass {
            background: rgba(39, 174, 96, 0.2);
            border-left: 4px solid #27ae60;
        }
        
        .test-fail {
            background: rgba(231, 76, 60, 0.2);
            border-left: 4px solid #e74c3c;
        }
        
        .test-warning {
            background: rgba(243, 156, 18, 0.2);
            border-left: 4px solid #f39c12;
        }
        
        .test-info {
            background: rgba(52, 152, 219, 0.2);
            border-left: 4px solid #3498db;
        }
        
        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        
        button:hover {
            background: #2980b9;
        }
        
        button:disabled {
            background: #7f8c8d;
            cursor: not-allowed;
        }
        
        .progress {
            width: 100%;
            height: 20px;
            background: #444;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            width: 0%;
            transition: width 0.3s;
        }
        
        .json-display {
            background: #1a1a1a;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <h1>üß™ CUBE Studio ControlNet System Test Suite</h1>
        
        <div class="test-section">
            <h2 class="test-header">üìä Test Progress</h2>
            <div class="progress">
                <div class="progress-bar" id="progress-bar"></div>
            </div>
            <p>Progress: <span id="progress-text">0%</span></p>
        </div>

        <div class="test-section">
            <h2 class="test-header">üîß Backend API Tests</h2>
            <button onclick="testBackendAPIs()">Run Backend API Tests</button>
            <div id="backend-results"></div>
        </div>

        <div class="test-section">
            <h2 class="test-header">üé® Frontend UI Tests</h2>
            <button onclick="testFrontendUI()">Test Frontend UI Components</button>
            <div id="frontend-results"></div>
        </div>

        <div class="test-section">
            <h2 class="test-header">üîó Integration Tests</h2>
            <button onclick="testIntegration()">Run Integration Tests</button>
            <div id="integration-results"></div>
        </div>

        <div class="test-section">
            <h2 class="test-header">‚ö° Performance Tests</h2>
            <button onclick="testPerformance()">Run Performance Tests</button>
            <div id="performance-results"></div>
        </div>

        <div class="test-section">
            <h2 class="test-header">üõ°Ô∏è Error Handling Tests</h2>
            <button onclick="testErrorHandling()">Test Error Handling</button>
            <div id="error-results"></div>
        </div>

        <div class="test-section">
            <h2 class="test-header">üì± Responsive Design Tests</h2>
            <button onclick="testResponsiveDesign()">Test Responsive Design</button>
            <div id="responsive-results"></div>
        </div>

        <div class="test-section">
            <h2 class="test-header">üìã Test Summary</h2>
            <button onclick="generateReport()">Generate Final Report</button>
            <div id="summary-results"></div>
        </div>

        <div class="test-section">
            <h2 class="test-header">üèÉ Quick Test Suite</h2>
            <button onclick="runAllTests()">Run All Tests</button>
            <button onclick="clearResults()">Clear All Results</button>
        </div>
    </div>

    <script>
        let testResults = {};
        let totalTests = 0;
        let completedTests = 0;

        function updateProgress() {
            const percentage = totalTests > 0 ? Math.round((completedTests / totalTests) * 100) : 0;
            document.getElementById('progress-bar').style.width = percentage + '%';
            document.getElementById('progress-text').textContent = percentage + '%';
        }

        function addResult(sectionId, testName, status, message, data = null) {
            const section = document.getElementById(sectionId);
            const result = document.createElement('div');
            result.className = `test-result test-${status}`;
            
            let content = `<strong>${testName}:</strong> ${message}`;
            if (data) {
                content += `<div class="json-display">${JSON.stringify(data, null, 2)}</div>`;
            }
            
            result.innerHTML = content;
            section.appendChild(result);
            
            if (!testResults[sectionId]) testResults[sectionId] = [];
            testResults[sectionId].push({ testName, status, message, data });
            
            completedTests++;
            updateProgress();
        }

        async function testBackendAPIs() {
            const sectionId = 'backend-results';
            document.getElementById(sectionId).innerHTML = '';
            
            const tests = [
                { name: 'Health Check', url: 'http://localhost:9004/api/health', expected: false },
                { name: 'Processors Categories', url: 'http://localhost:9004/api/processors/categories', expected: true },
                { name: 'Processors Stats', url: 'http://localhost:9004/api/processors/stats', expected: true },
                { name: 'Legacy Preprocessors', url: 'http://localhost:9004/api/preprocessors', expected: true }
            ];

            totalTests += tests.length;

            for (const test of tests) {
                try {
                    const response = await fetch(test.url);
                    const data = await response.json();
                    
                    if (response.ok && test.expected) {
                        addResult(sectionId, test.name, 'pass', `‚úÖ OK (${response.status})`, data);
                    } else if (!response.ok && !test.expected) {
                        addResult(sectionId, test.name, 'pass', `‚úÖ Expected failure (${response.status})`, data);
                    } else {
                        addResult(sectionId, test.name, 'fail', `‚ùå Unexpected result (${response.status})`, data);
                    }
                } catch (error) {
                    addResult(sectionId, test.name, 'fail', `‚ùå Network error: ${error.message}`);
                }
            }
        }

        async function testFrontendUI() {
            const sectionId = 'frontend-results';
            document.getElementById(sectionId).innerHTML = '';
            
            const uiTests = [
                { name: 'Canvas Container', selector: '#canvas-container', expected: true },
                { name: 'Generation Panel Container', selector: '#generation-panel-container', expected: true },
                { name: 'Konva.js Library', check: () => window.Konva !== undefined, expected: true },
                { name: 'App Initialization', check: () => window.generationPanel !== undefined, expected: true },
                { name: 'State Manager', check: () => window.stateManager !== undefined, expected: true }
            ];

            totalTests += uiTests.length;

            for (const test of uiTests) {
                try {
                    let result;
                    if (test.selector) {
                        result = document.querySelector(test.selector) !== null;
                    } else if (test.check) {
                        result = test.check();
                    }
                    
                    if (result === test.expected) {
                        addResult(sectionId, test.name, 'pass', `‚úÖ Found and working`);
                    } else {
                        addResult(sectionId, test.name, 'fail', `‚ùå Not found or not working`);
                    }
                } catch (error) {
                    addResult(sectionId, test.name, 'fail', `‚ùå Error: ${error.message}`);
                }
            }
        }

        async function testIntegration() {
            const sectionId = 'integration-results';
            document.getElementById(sectionId).innerHTML = '';
            
            totalTests += 3;

            // Test 1: Can create dummy image on canvas
            try {
                if (window.Konva) {
                    addResult(sectionId, 'Canvas Creation', 'pass', '‚úÖ Can access Konva for canvas operations');
                } else {
                    addResult(sectionId, 'Canvas Creation', 'fail', '‚ùå Konva library not available');
                }
            } catch (error) {
                addResult(sectionId, 'Canvas Creation', 'fail', `‚ùå Error: ${error.message}`);
            }

            // Test 2: Backend + Frontend communication
            try {
                const response = await fetch('http://localhost:9004/api/processors/categories');
                const categories = await response.json();
                
                if (response.ok && categories.edge_detection) {
                    addResult(sectionId, 'Backend-Frontend Communication', 'pass', '‚úÖ Successfully fetched categories for UI');
                } else {
                    addResult(sectionId, 'Backend-Frontend Communication', 'fail', '‚ùå Could not fetch valid categories');
                }
            } catch (error) {
                addResult(sectionId, 'Backend-Frontend Communication', 'fail', `‚ùå Communication error: ${error.message}`);
            }

            // Test 3: State management
            try {
                if (window.stateManager && typeof window.stateManager.updateState === 'function') {
                    addResult(sectionId, 'State Management', 'pass', '‚úÖ State manager is functional');
                } else {
                    addResult(sectionId, 'State Management', 'warning', '‚ö†Ô∏è State manager not found or incomplete');
                }
            } catch (error) {
                addResult(sectionId, 'State Management', 'fail', `‚ùå Error: ${error.message}`);
            }
        }

        async function testPerformance() {
            const sectionId = 'performance-results';
            document.getElementById(sectionId).innerHTML = '';
            
            totalTests += 4;

            // Test 1: Backend response time
            try {
                const startTime = performance.now();
                const response = await fetch('http://localhost:9004/api/processors/stats');
                const endTime = performance.now();
                const responseTime = endTime - startTime;
                
                if (responseTime < 1000) {
                    addResult(sectionId, 'Backend Response Time', 'pass', `‚úÖ ${responseTime.toFixed(2)}ms (< 1s)`);
                } else if (responseTime < 3000) {
                    addResult(sectionId, 'Backend Response Time', 'warning', `‚ö†Ô∏è ${responseTime.toFixed(2)}ms (< 3s)`);
                } else {
                    addResult(sectionId, 'Backend Response Time', 'fail', `‚ùå ${responseTime.toFixed(2)}ms (> 3s)`);
                }
            } catch (error) {
                addResult(sectionId, 'Backend Response Time', 'fail', `‚ùå Error: ${error.message}`);
            }

            // Test 2: Memory usage
            try {
                if (performance.memory) {
                    const memUsed = performance.memory.usedJSHeapSize / 1024 / 1024; // MB
                    if (memUsed < 100) {
                        addResult(sectionId, 'Memory Usage', 'pass', `‚úÖ ${memUsed.toFixed(2)}MB (< 100MB)`);
                    } else if (memUsed < 200) {
                        addResult(sectionId, 'Memory Usage', 'warning', `‚ö†Ô∏è ${memUsed.toFixed(2)}MB (< 200MB)`);
                    } else {
                        addResult(sectionId, 'Memory Usage', 'fail', `‚ùå ${memUsed.toFixed(2)}MB (> 200MB)`);
                    }
                } else {
                    addResult(sectionId, 'Memory Usage', 'info', '‚ÑπÔ∏è Memory API not available');
                }
            } catch (error) {
                addResult(sectionId, 'Memory Usage', 'fail', `‚ùå Error: ${error.message}`);
            }

            // Test 3: DOM rendering performance
            try {
                const startTime = performance.now();
                const testDiv = document.createElement('div');
                testDiv.innerHTML = '<div>'.repeat(1000) + '</div>'.repeat(1000);
                document.body.appendChild(testDiv);
                document.body.removeChild(testDiv);
                const endTime = performance.now();
                const renderTime = endTime - startTime;
                
                if (renderTime < 100) {
                    addResult(sectionId, 'DOM Rendering', 'pass', `‚úÖ ${renderTime.toFixed(2)}ms (< 100ms)`);
                } else {
                    addResult(sectionId, 'DOM Rendering', 'warning', `‚ö†Ô∏è ${renderTime.toFixed(2)}ms (> 100ms)`);
                }
            } catch (error) {
                addResult(sectionId, 'DOM Rendering', 'fail', `‚ùå Error: ${error.message}`);
            }

            // Test 4: Canvas performance
            try {
                if (window.Konva) {
                    const startTime = performance.now();
                    const stage = new Konva.Stage({
                        container: document.body,
                        width: 500,
                        height: 500
                    });
                    const layer = new Konva.Layer();
                    
                    // Add many shapes to test performance
                    for (let i = 0; i < 100; i++) {
                        const rect = new Konva.Rect({
                            x: Math.random() * 400,
                            y: Math.random() * 400,
                            width: 20,
                            height: 20,
                            fill: 'red'
                        });
                        layer.add(rect);
                    }
                    
                    stage.add(layer);
                    layer.draw();
                    
                    const endTime = performance.now();
                    const canvasTime = endTime - startTime;
                    
                    // Cleanup
                    stage.destroy();
                    
                    if (canvasTime < 100) {
                        addResult(sectionId, 'Canvas Performance', 'pass', `‚úÖ ${canvasTime.toFixed(2)}ms (< 100ms)`);
                    } else {
                        addResult(sectionId, 'Canvas Performance', 'warning', `‚ö†Ô∏è ${canvasTime.toFixed(2)}ms (> 100ms)`);
                    }
                } else {
                    addResult(sectionId, 'Canvas Performance', 'fail', '‚ùå Konva not available');
                }
            } catch (error) {
                addResult(sectionId, 'Canvas Performance', 'fail', `‚ùå Error: ${error.message}`);
            }
        }

        async function testErrorHandling() {
            const sectionId = 'error-results';
            document.getElementById(sectionId).innerHTML = '';
            
            totalTests += 3;

            // Test 1: Invalid API endpoint
            try {
                const response = await fetch('http://localhost:9004/api/invalid-endpoint');
                if (response.status === 404) {
                    addResult(sectionId, 'Invalid Endpoint Handling', 'pass', '‚úÖ Properly returns 404 for invalid endpoints');
                } else {
                    addResult(sectionId, 'Invalid Endpoint Handling', 'warning', `‚ö†Ô∏è Unexpected status: ${response.status}`);
                }
            } catch (error) {
                addResult(sectionId, 'Invalid Endpoint Handling', 'fail', `‚ùå Network error: ${error.message}`);
            }

            // Test 2: Backend unavailable simulation
            try {
                const response = await fetch('http://localhost:9999/api/test');
                addResult(sectionId, 'Backend Unavailable', 'fail', '‚ùå Should have failed but didn\'t');
            } catch (error) {
                if (error.message.includes('fetch')) {
                    addResult(sectionId, 'Backend Unavailable', 'pass', '‚úÖ Properly handles backend unavailable');
                } else {
                    addResult(sectionId, 'Backend Unavailable', 'warning', `‚ö†Ô∏è Unexpected error: ${error.message}`);
                }
            }

            // Test 3: JavaScript error handling
            try {
                // Intentionally cause an error
                window.nonExistentFunction();
                addResult(sectionId, 'JavaScript Error Handling', 'fail', '‚ùå Should have thrown an error');
            } catch (error) {
                addResult(sectionId, 'JavaScript Error Handling', 'pass', `‚úÖ Properly caught error: ${error.name}`);
            }
        }

        async function testResponsiveDesign() {
            const sectionId = 'responsive-results';
            document.getElementById(sectionId).innerHTML = '';
            
            totalTests += 3;

            // Test 1: Viewport meta tag
            const viewportMeta = document.querySelector('meta[name="viewport"]');
            if (viewportMeta && viewportMeta.content.includes('width=device-width')) {
                addResult(sectionId, 'Viewport Meta Tag', 'pass', '‚úÖ Proper viewport meta tag found');
            } else {
                addResult(sectionId, 'Viewport Meta Tag', 'fail', '‚ùå Missing or invalid viewport meta tag');
            }

            // Test 2: CSS media queries support
            if (window.matchMedia) {
                const mobileQuery = window.matchMedia('(max-width: 768px)');
                addResult(sectionId, 'Media Queries Support', 'pass', `‚úÖ Media queries supported. Mobile: ${mobileQuery.matches}`);
            } else {
                addResult(sectionId, 'Media Queries Support', 'fail', '‚ùå Media queries not supported');
            }

            // Test 3: Element scaling
            const testElement = document.createElement('div');
            testElement.style.cssText = 'width: 50vw; height: 50vh; position: absolute; visibility: hidden;';
            document.body.appendChild(testElement);
            
            const computedStyle = window.getComputedStyle(testElement);
            const widthPx = parseInt(computedStyle.width);
            const heightPx = parseInt(computedStyle.height);
            
            document.body.removeChild(testElement);
            
            if (widthPx > 0 && heightPx > 0) {
                addResult(sectionId, 'Viewport Units', 'pass', `‚úÖ Viewport units work (${widthPx}x${heightPx})`);
            } else {
                addResult(sectionId, 'Viewport Units', 'fail', '‚ùå Viewport units not working');
            }
        }

        function generateReport() {
            const sectionId = 'summary-results';
            document.getElementById(sectionId).innerHTML = '';
            
            let totalPassed = 0;
            let totalFailed = 0;
            let totalWarnings = 0;
            let totalInfo = 0;
            let totalTestsRun = 0;

            for (const section in testResults) {
                testResults[section].forEach(result => {
                    totalTestsRun++;
                    switch (result.status) {
                        case 'pass': totalPassed++; break;
                        case 'fail': totalFailed++; break;
                        case 'warning': totalWarnings++; break;
                        case 'info': totalInfo++; break;
                    }
                });
            }

            const passRate = totalTestsRun > 0 ? (totalPassed / totalTestsRun * 100).toFixed(1) : 0;
            
            let overallStatus = 'pass';
            if (totalFailed > 0) overallStatus = 'fail';
            else if (totalWarnings > 0) overallStatus = 'warning';

            const summary = {
                timestamp: new Date().toISOString(),
                totalTests: totalTestsRun,
                passed: totalPassed,
                failed: totalFailed,
                warnings: totalWarnings,
                info: totalInfo,
                passRate: `${passRate}%`,
                overallStatus: overallStatus,
                details: testResults
            };

            const reportElement = document.createElement('div');
            reportElement.innerHTML = `
                <div class="test-result test-${overallStatus}">
                    <h3>üìä Test Summary Report</h3>
                    <p><strong>Overall Status:</strong> ${overallStatus.toUpperCase()}</p>
                    <p><strong>Pass Rate:</strong> ${passRate}% (${totalPassed}/${totalTestsRun})</p>
                    <p><strong>‚úÖ Passed:</strong> ${totalPassed}</p>
                    <p><strong>‚ùå Failed:</strong> ${totalFailed}</p>
                    <p><strong>‚ö†Ô∏è Warnings:</strong> ${totalWarnings}</p>
                    <p><strong>‚ÑπÔ∏è Info:</strong> ${totalInfo}</p>
                    <p><strong>üïê Timestamp:</strong> ${new Date().toLocaleString()}</p>
                </div>
                <div class="json-display">${JSON.stringify(summary, null, 2)}</div>
            `;
            
            document.getElementById(sectionId).appendChild(reportElement);
        }

        async function runAllTests() {
            clearResults();
            totalTests = 0;
            completedTests = 0;
            
            console.log('üöÄ Starting comprehensive test suite...');
            
            await testBackendAPIs();
            await testFrontendUI();
            await testIntegration();
            await testPerformance();
            await testErrorHandling();
            await testResponsiveDesign();
            
            generateReport();
            
            console.log('‚úÖ All tests completed!');
        }

        function clearResults() {
            const resultSections = [
                'backend-results', 'frontend-results', 'integration-results',
                'performance-results', 'error-results', 'responsive-results', 'summary-results'
            ];
            
            resultSections.forEach(sectionId => {
                document.getElementById(sectionId).innerHTML = '';
            });
            
            testResults = {};
            totalTests = 0;
            completedTests = 0;
            updateProgress();
        }

        // Auto-run basic tests on page load
        window.addEventListener('load', () => {
            console.log('üß™ Test page loaded. Ready for testing!');
            console.log('üí° Use runAllTests() to run the complete test suite');
        });
    </script>
</body>
</html>